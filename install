#!/usr/bin/env bash
#########################################################################################
# Install command utilities
#
# Description:
#&  Install this: put settings in `echo_yellow '~/.bash_command' -n`
#
#   Install utility commands:
#     We don't use submodule/superproject of git because of be difficult for
#     managing. Therefore, we just define commands and clone theme.
#&      `printf '%s\\n      ' "${CMD_LIST[@]}" | sed '/^[[:space:]]*$/d'`
#
#&    Select option is command name to install or `echo_yellow -a -n` to intall all.
#########################################################################################
BASE_DIR=`cd $(dirname "$0"); pwd`

#-------------------------------------------------
CMD_GIT_REPOSITORY='git@github.com:nth806'
CMD_LIST=( cmdsh )

function installCommand () {
  local UTIL_CMD=${1}
  if [ -d ${UTIL_CMD} ]
  then
    echo_yellow "The ${1} has already installed."
  else
    git clone ${CMD_GIT_REPOSITORY}/${UTIL_CMD}.git ${UTIL_CMD}
  fi
}

#-------------------------------------------------
_ENV=.env
_SH_COMPLETION_DIR=completion.d

function inputWorkspace () {
  read -e -p "- Workspace: " WORKSPACE
  if [ ! -z "${WORKSPACE}" ]
  then
    [ ! -d "${WORKSPACE}" ] && echo_yellow 'Workspace must be existed directory!' && return

    ! cmn_isStartWith / "${WORKSPACE}" && echo_yellow 'Workspace must be absoluted path!' && return
  fi
}

declare -A PROJECT_INDEXES

PROJECT_NAME=begin
function inputProject () {
  read -e -p "- Project name and its index: " PROJECT_NAME

  [[ -z "$PROJECT_NAME" ]] && return

  local pj_nm=`echo $PROJECT_NAME | cut -f1 -d" "`
  local pj_idx=`echo $PROJECT_NAME | cut -f2 -d" "`
  pj_nm=`cmn_trimSlash "${pj_nm}"`

  [ ! -d "${pj_nm}" ] && echo_yellow "Project name must be a folder in workspace ${WORKSPACE}" && return

  [ -z "$pj_idx" ] && pj_idx=${pj_nm}
  pj_idx=`cmn_trimSlash "${pj_idx}"`
  [[ "${pj_idx}" =~ [^_\.a-zA-Z0-9\-] ]] && echo_yellow "Index is invalid" && return

  PROJECT_INDEXES[${pj_nm}]="${pj_idx}"
}

#-------------------------------------------------
# Include common functions of bash
. $BASE_DIR/include/src

# Show help
if [ "x${1}" = "x-h" ] || [ "x${1}" = "x--help" ]
then
  inc_itselfHelp
fi

echo $SHELL_NAME
#-------------------------------------------------
#### Main process ####
cd "${BASE_DIR}"

if [ "x$SHELL_NAME" = 'xzsh' ]
then
  if [ -f ~/.zshrc ]
  then
    _INIT_SH=~/.zshrc
  elif [ -f ~/.zprofile ]
  then
    _INIT_SH=~/.zprofile
  elif [ -f ~/.zshenv ]
  then
    _INIT_SH=~/.zshenv
  else
    echo_yellow "Can't locate the initial zsh script"
    exit
  fi

  _SH_COMMAND=~/.zsh_command
  _SH_COMPLETION=~/.zsh_completion.d
else
  # Default bash
  if [ -f ~/.bashrc ]
  then
    _INIT_SH=~/.bashrc
  elif [ -f ~/.profile ]
  then
    _INIT_SH=~/.profile
  elif [ -f ~/.bash_profile ]
  then
    _INIT_SH=~/.bash_profile
  else
    echo_yellow "Can't locate the initial bash script"
    exit
  fi

  _SH_COMMAND=~/.bash_command
  _SH_COMPLETION=~/.bash_completion
fi

# Install this: put .env settings
if [ ! -f $_ENV ]
then
  # Do install
  echo_blue 'Input absoluted path to your workspace (where you locate projects'"'"' source).'
  while [[ -z "${WORKSPACE}" ]] || [ ! -d "${WORKSPACE}" ] || ! cmn_isStartWith / "${WORKSPACE}"
  do
    inputWorkspace
  done

  WORKSPACE=`cmn_rmTrailingWith / "${WORKSPACE}"`

  cd "${WORKSPACE}"
  echo_blue 'Input the the projects'"'"' name and their index in the workspace one by one.'
  echo_blue 'Name or its index should only contain alphanumerics and _.- or let it empty to continue.'
  echo_blue 'Input index following name separated by spaces or let it empty to set it as name.'
  while [[ ! -z "${PROJECT_NAME}" ]]
  do
    inputProject
  done
  cd "${BASE_DIR}"

  #--------------------------
  # Create init sh files
  lc_strlist='aliases.sh paths.sh functions.sh'
  for lc in $lc_strlist
  do
    if [ ! -f profile/sh/{$lc} ]
    then
      echo > profile/sh/$lc
    fi
  done

  #--------------------------
  # Add .env file
  echo "WORKSPACE=${WORKSPACE}"$'\n' >> $_ENV

  echo '#### Directory changing settings' >> $_ENV
  echo 'declare -A CD_DEFAULT' >> $_ENV
  echo 'CD_DEFAULT[ws]="${WORKSPACE}"'$'\n' >> $_ENV

  echo '#### Projects settings' >> $_ENV
  echo 'declare -A PROJECT_INDEXES' >> $_ENV
  for i in "${!PROJECT_INDEXES[@]}"
  do
    echo "PROJECT_INDEXES[${PROJECT_INDEXES[${i}]}]=${i}" >> $_ENV
  done

  echo >> $_ENV
  echo '# Absolute paths' >> $_ENV
  echo 'PROJECT_INDEXES[c]=${COMMAND_DIR}' >> $_ENV
  echo 'PROJECT_INDEXES[sh]=${COMMAND_DIR}/cmdsh'$'\n' >> $_ENV
fi

#--------------------------
# Add ~/.bash_command file
if [ ! -f $_SH_COMMAND ]
then
  echo '#### Utility Command ####' >> $_SH_COMMAND
  echo "COMMAND_DIR=${WORK_DIR}" >> $_SH_COMMAND
  echo '. $COMMAND_DIR/'${_ENV}$'\n' >> $_SH_COMMAND

  echo 'function ssh_add_keys() {' >> $_SH_COMMAND
  echo '  echo ssh-add ~/.ssh/id_rsa' >> $_SH_COMMAND
  echo '}'$'\n' >> $_SH_COMMAND

  echo '# System variables' >> $_SH_COMMAND
  echo 'M_OS=`uname | tr '"'[:upper:]' '[:lower:]'"'`' >> $_SH_COMMAND
  echo 'if [ "x${M_OS:0:5}" = '"'xmingw'"' ]' >> $_SH_COMMAND
  echo 'then' >> $_SH_COMMAND
  echo '  M_OS=gitbash' >> $_SH_COMMAND
  echo 'fi'$'\n' >> $_SH_COMMAND

  echo '# Utility commands' >> $_SH_COMMAND
  echo 'if [ -d $COMMAND_DIR/include ]; then' >> $_SH_COMMAND
  echo '  . $COMMAND_DIR/include/src'$'\n' >> $_SH_COMMAND

  echo '  # Profile for OS' >> $_SH_COMMAND
  echo '  . $COMMAND_DIR/profile/${M_OS}.sh' >> $_SH_COMMAND
  echo 'else' >> $_SH_COMMAND
  echo '  echo '"'"'There is no path for common functions!'"'" >> $_SH_COMMAND
  echo 'fi'$'\n' >> $_SH_COMMAND

  echo 'PATH=$PATH:$COMMAND_DIR/cmdsh:$COMMAND_DIR/profile/sh:$COMMAND_DIR/cmd/${M_OS}:$COMMAND_DIR/cmd/sh'$'\n' >> $_SH_COMMAND

  echo 'unset lc_script lc_dir lc_basename' >> $_SH_COMMAND
  echo 'export PATH'$'\n' >> $_SH_COMMAND

  # Source .bash_command
  _SH_COMMAND='~'`cmn_rmLeadingWith $HOME $_SH_COMMAND`
  cat $_INIT_SH | grep '. '"${_SH_COMMAND}" > /dev/null
  if [ $? -ne 0 ]
  then
    echo $'\n# Custom command utilities' >> $_INIT_SH
    echo '. '"${_SH_COMMAND}" >> $_INIT_SH
    echo >> $_INIT_SH
  fi
fi

COMPLETION_MARKER='# Custom completion utilities'
REQUIRE_SH_COMPLETION=1
if [ "x$SHELL_NAME" = 'xzsh' ]
then
  SH_COMPLETION_DIR=$BASE_DIR/cmdsh/${_SH_COMPLETION_DIR}
  cat $_INIT_SH | grep "$COMPLETION_MARKER" > /dev/null
  if [ $? -ne 0 ]
  then
    REQUIRE_SH_COMPLETION=0
  fi

  if [ $REQUIRE_SH_COMPLETION -eq 0 ] && [ -d "$SH_COMPLETION_DIR" ]
  then
    echo "${COMPLETION_MARKER}" >> $_INIT_SH
    echo 'fpath=('${SH_COMPLETION_DIR}' $fpath)' >> $_INIT_SH
    echo 'autoload -U compinit' >> $_INIT_SH
    #echo 'compinit' >> $_INIT_SH
    echo 'compinit -i'$'\n' >> $_INIT_SH

    echo 'if [ ${#GU_ALLIASES} -gt 0 ]; then' >> $_INIT_SH
    echo '  for val i in "${(@kv)GU_ALLIASES}"; do' >> $_INIT_SH
    echo '    alias $val="gu $i"' >> $_INIT_SH
    echo '    #compdef _gu $val' >> $_INIT_SH
    echo '  done' >> $_INIT_SH
    echo '  unset i val' >> $_INIT_SH
    echo 'fi'$'\n' >> $_INIT_SH
  fi
else
  if [ ! -f $_SH_COMPLETION ]
  then
    REQUIRE_SH_COMPLETION=0
  else
    cat $_SH_COMPLETION | grep "$COMPLETION_MARKER" > /dev/null
    if [ $? -ne 0 ]
    then
      REQUIRE_SH_COMPLETION=0
    fi
  fi

  if [ $REQUIRE_SH_COMPLETION -eq 0 ]
  then
    # Add source completion scripts
    echo "${COMPLETION_MARKER}" >> $_SH_COMPLETION
    echo 'if [ -d '${COMMAND_DIR}'/cmdsh/'${_SH_COMPLETION_DIR}' ]; then' >> $_SH_COMPLETION
    echo '  for lc_script in `find '${COMMAND_DIR}'/cmdsh/'${_SH_COMPLETION_DIR}' -type f -name '"'"'*.bash'"'"'`' >> $_SH_COMPLETION
    echo '  do' >> $_SH_COMPLETION
    echo '    . $lc_script' >> $_SH_COMPLETION
    echo '  done' >> $_SH_COMPLETION
    echo '  unset lc_script'$'\n' >> $_SH_COMPLETION

    echo '  if [ ${#GU_ALLIASES[@]} -gt 0 ]; then' >> $_SH_COMPLETION
    echo '    for i in "${!GU_ALLIASES[@]}"; do' >> $_SH_COMPLETION
    echo '      alias $i='"'"'gu '"'"'${GU_ALLIASES[$i]}' >> $_SH_COMPLETION
    echo '      ___gu_complete $i __gu_main' >> $_SH_COMPLETION
    echo '    done' >> $_SH_COMPLETION
    echo '    unset i' >> $_SH_COMPLETION
    echo '  fi' >> $_SH_COMPLETION
    echo 'fi' >> $_SH_COMPLETION
    echo >> $_SH_COMPLETION
  fi
fi

# Install utility commands
[[ -z "$1" ]] && exit
if [ "x${1}" = 'x-a' ]
then
  for lc in "${CMD_LIST[@]}"
  do
    installCommand ${lc}
  done

  exit
fi

[[ "${CMD_LIST[*]}" =~ (^|[[:space:]])$1($|[[:space:]]) ]] || cmn_exitAbnormal 'Invalid command!'

installCommand $1
